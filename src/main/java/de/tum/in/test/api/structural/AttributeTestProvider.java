package de.tum.in.test.api.structural;

import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
import static org.junit.jupiter.api.DynamicTest.dynamicTest;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;

import org.json.JSONArray;
import org.junit.jupiter.api.DynamicContainer;
import org.junit.jupiter.api.DynamicNode;

/**
 * This test evaluates if the specified attributes in the structure oracle are
 * correctly implemented with the expected type, visibility modifiers and
 * annotations, based on its definition in the structure oracle (test.json).
 *
 * @author Stephan Krusche (krusche@in.tum.de)
 * @version 5.0 (11.11.2020)
 */
public abstract class AttributeTestProvider extends StructuralTestProvider {

	/**
	 * This method collects the classes in the structure oracle file for which
	 * attributes are specified. These classes are then transformed into JUnit 5
	 * dynamic tests.
	 *
	 * @return A dynamic test container containing the test for each class which is
	 *         then executed by JUnit.
	 * @throws URISyntaxException an exception if the URI of the class name cannot
	 *                            be generated (which seems to be unlikely)
	 */
	protected DynamicContainer generateTestsForAllClasses() throws URISyntaxException {
		List<DynamicNode> tests = new ArrayList<>();
		if (structureOracleJSON == null)
			fail("The AttributeTest test can only run if the structural oracle (test.json) is present. If you do not provide it, delete AttributeTest.java!");
		for (var i = 0; i < structureOracleJSON.length(); i++) {
			var expectedClassJSON = structureOracleJSON.getJSONObject(i);
			// Only test the classes that have attributes defined in the oracle.
			if (expectedClassJSON.has(JSON_PROPERTY_CLASS) && (expectedClassJSON.has(JSON_PROPERTY_ATTRIBUTES)
					|| expectedClassJSON.has(JSON_PROPERTY_ENUM_VALUES))) {
				var expectedClassPropertiesJSON = expectedClassJSON.getJSONObject(JSON_PROPERTY_CLASS);
				var expectedClassName = expectedClassPropertiesJSON.getString(JSON_PROPERTY_NAME);
				var expectedPackageName = expectedClassPropertiesJSON.getString(JSON_PROPERTY_PACKAGE);
				var expectedClassStructure = new ExpectedClassStructure(expectedClassName, expectedPackageName,
						expectedClassJSON);
				tests.add(dynamicTest("testAttributes[" + expectedClassName + "]",
						() -> testAttributes(expectedClassStructure)));
			}
		}
		if (tests.isEmpty())
			fail("No tests for attributes available in the structural oracle (test.json). Either provide attributes information or delete AttributeTest.java!");
		/*
		 * Using a custom URI here to workaround surefire rendering the JUnit XML
		 * without the correct test names.
		 */
		return dynamicContainer(getClass().getName(), new URI(getClass().getName()), tests.stream());
	}

	/**
	 * This method gets passed the expected class structure generated by the method
	 * {@link #generateTestsForAllClasses()}, checks if the class is found at all in
	 * the assignment and then proceeds to check its attributes.
	 *
	 * @param expectedClassStructure The class structure that we expect to find and
	 *                               test against.
	 */
	protected static void testAttributes(ExpectedClassStructure expectedClassStructure) {
		var expectedClassName = expectedClassStructure.getExpectedClassName();
		var observedClass = findClassForTestType(expectedClassStructure, "attribute");
		if (observedClass == null) {
			fail(THE_CLASS + expectedClassName + " was not found for attribute test");
			return;
		}
		if (expectedClassStructure.hasProperty(JSON_PROPERTY_ATTRIBUTES)) {
			var expectedAttributes = expectedClassStructure.getPropertyAsJsonArray(JSON_PROPERTY_ATTRIBUTES);
			checkAttributes(expectedClassName, observedClass, expectedAttributes);
		}
		if (expectedClassStructure.hasProperty(JSON_PROPERTY_ENUM_VALUES)) {
			var expectedEnumValues = expectedClassStructure.getPropertyAsJsonArray(JSON_PROPERTY_ENUM_VALUES);
			checkEnumValues(expectedClassName, observedClass, expectedEnumValues);
		}
	}

	/**
	 * This method checks if a observed class' attributes match the expected ones
	 * defined in the structure oracle.
	 *
	 * @param expectedClassName  The simple name of the class, mainly used for error
	 *                           messages.
	 * @param observedClass      The class that needs to be checked as a Class
	 *                           object.
	 * @param expectedAttributes The information on the expected attributes
	 *                           contained in a JSON array. This information
	 *                           consists of the name, the type and the visibility
	 *                           modifiers of each attribute.
	 */
	protected static void checkAttributes(String expectedClassName, Class<?> observedClass,
			JSONArray expectedAttributes) {
		for (var i = 0; i < expectedAttributes.length(); i++) {
			var expectedAttribute = expectedAttributes.getJSONObject(i);
			var expectedName = expectedAttribute.getString(JSON_PROPERTY_NAME);
			var expectedTypeName = expectedAttribute.getString(JSON_PROPERTY_TYPE);
			var expectedModifiers = getExpectedJsonProperty(expectedAttribute, JSON_PROPERTY_MODIFIERS);
			var expectedAnnotations = getExpectedJsonProperty(expectedAttribute, JSON_PROPERTY_ANNOTATIONS);

			// We check for each expected attribute if the name and the type is right.
			var nameIsCorrect = false;
			var typeIsCorrect = false;
			var modifiersAreCorrect = false;
			var annotationsAreCorrect = false;

			for (Field observedAttribute : observedClass.getDeclaredFields()) {
				if (expectedName.equals(observedAttribute.getName())) {
					nameIsCorrect = true;
					typeIsCorrect = checkExpectedType(observedAttribute.getType(), observedAttribute.getGenericType(),
							expectedTypeName);
					modifiersAreCorrect = checkModifiers(Modifier.toString(observedAttribute.getModifiers()).split(" "),
							expectedModifiers);
					annotationsAreCorrect = checkAnnotations(observedAttribute.getAnnotations(), expectedAnnotations);
					// If all are correct, then we found our attribute and we can break the loop
					if (typeIsCorrect && modifiersAreCorrect && annotationsAreCorrect)
						break;
				}
				// TODO: we should also take wrong case and typos into account (the else case)
			}
			checkAttributeCorrectness(nameIsCorrect, typeIsCorrect, modifiersAreCorrect, annotationsAreCorrect,
					expectedName, expectedClassName);
		}
	}

	private static void checkAttributeCorrectness(boolean nameIsCorrect, boolean typeIsCorrect,
			boolean modifiersAreCorrect, boolean annotationsAreCorrect, String expectedName, String expectedClassName) {
		var expectedAttributeInformation = "the expected attribute '" + expectedName + "' of the class '"
				+ expectedClassName + "'";
		if (!nameIsCorrect)
			fail("The name of " + expectedAttributeInformation + " is not implemented as expected.");
		if (!typeIsCorrect)
			fail("The type of " + expectedAttributeInformation + " is not implemented as expected.");
		if (!modifiersAreCorrect)
			fail("The modifier(s) (access type, abstract, etc.) of " + expectedAttributeInformation
					+ NOT_IMPLEMENTED_AS_EXPECTED);
		if (!annotationsAreCorrect)
			fail("The annotation(s) of " + expectedAttributeInformation + NOT_IMPLEMENTED_AS_EXPECTED);
	}

	/**
	 * This method checks if the observed enum values match the expected ones
	 * defined in the structure oracle.
	 *
	 * @param expectedClassName  The simple name of the class, mainly used for error
	 *                           messages.
	 * @param observedClass      The enum that needs to be checked as a Class
	 *                           object.
	 * @param expectedEnumValues The information on the expected enum values
	 *                           contained in a JSON array. This information
	 *                           consists of the name of each enum value.
	 */
	protected static void checkEnumValues(String expectedClassName, Class<?> observedClass,
			JSONArray expectedEnumValues) {
		Object[] observedEnumValues = observedClass.getEnumConstants();
		if (observedEnumValues == null) {
			fail(THE_ENUM + "'" + expectedClassName
					+ "' does not contain any enum constants. Make sure to implement them.");
			return;
		}
		if (expectedEnumValues.length() != observedEnumValues.length) {
			fail(THE_ENUM + "'" + expectedClassName
					+ "' does not contain all the expected enum values. Make sure to implement the missing enums.");
			return;
		}
		for (var i = 0; i < expectedEnumValues.length(); i++) {
			var expectedEnumValue = expectedEnumValues.getString(i);
			var enumValueExists = false;
			for (Object observedEnumValue : observedEnumValues) {
				if (expectedEnumValue.equals(((Enum<?>) observedEnumValue).name())) {
					enumValueExists = true;
					break;
				}
			}
			if (!enumValueExists)
				fail(THE_CLASS + "'" + expectedClassName + "' does not include the enum value: " + expectedEnumValue
						+ ". Make sure to implement it as expected.");
		}
	}
}
